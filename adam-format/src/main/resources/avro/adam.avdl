@namespace("edu.berkeley.cs.amplab.adam.avro")
protocol ADAM {

record ADAMRecord {

    /**
     * These two fields, along with the two
     * reference{Length, Url} fields at the bottom
     * of the schema, collectively form the contents
     * of the Sequence Dictionary embedded in the these
     * records from the BAM / SAM itself.
     */
    union { null, string } referenceName = null;
    union { null, int } referenceId = null;

    // 0-based reference position start
    union { null, long } start = null;

    union { null, int } mapq = null;
    union { null, string } readName = null;
    union { null, string } sequence = null;
    union { null, string } mateReference = null;
    union { null, long } mateAlignmentStart = null;
    union { null, string } cigar = null;
    union { null, string } qual = null;
    union { null, string } recordGroupId = null;

    // Read flags (all default to false)
    union { boolean, null } readPaired = false;
    union { boolean, null } properPair = false;
    union { boolean, null } readMapped = false;
    union { boolean, null } mateMapped = false;
    union { boolean, null } readNegativeStrand = false;
    union { boolean, null } mateNegativeStrand = false;
    union { boolean, null } firstOfPair = false;
    union { boolean, null } secondOfPair = false;
    union { boolean, null } primaryAlignment = false;
    union { boolean, null } failedVendorQualityChecks = false;
    union { boolean, null } duplicateRead = false;

    // Commonly used optional attributes
    union { null, string } mismatchingPositions = null;

    // Remaining optional attributes flattened into a string
    union { null, string } attributes = null;

    union { null, string } recordGroupSequencingCenter = null;
    union { null, string } recordGroupDescription = null;
    union { null, long } recordGroupRunDateEpoch = null;
    union { null, string } recordGroupFlowOrder = null;
    union { null, string } recordGroupKeySequence = null;
    union { null, string } recordGroupLibrary = null;
    union { null, int } recordGroupPredictedMedianInsertSize = null;
    union { null, string } recordGroupPlatform = null;
    union { null, string } recordGroupPlatformUnit = null;
    union { null, string } recordGroupSample = null;

    union { null, int } mateReferenceId = null;

    // See note, above.
    union { null, long }   referenceLength = null;
    union { null, string } referenceUrl = null;

    union { null, long } mateReferenceLength = null;
    union { null, string } mateReferenceUrl = null;
}

record ADAMFastaFragment {
    union {null, string } description = null;
    union {null, long } start = null;
    union {null, long } end = null;
    union {null, string } sequence = null;
}

enum Base {
    A,
    C,
    T,
    G,
    U,
    N, // any
    X, // any
    K, // keto: G/T
    M, // aMino: A/C
    R, // puRine: A/G
    Y, // pYriminidine: C/T
    S, // Strong: C/G
    W, // Weak: A/T
    B, // not A
    V, // not T
    H, // not G
    D  // not C
}

record ADAMPileup {
    union { null, string } referenceName = null;
    union { null, int } referenceId = null;
    union { null, long } position = null;
    union { null, int } rangeOffset = null;
    union { null, int } rangeLength = null;
    union { null, Base } referenceBase = null;
    union { null, Base } readBase = null;
    union { null, int } sangerQuality = null;
    union { null, int } mapQuality = null;
    union { null, int } numSoftClipped = null;
    union { null, int } numReverseStrand = null;
    union { null, int } countAtPosition = null;
    union { null, string } readName = null;
    union { null, long } readStart = null;
    union { null, long } readEnd = null;
    union { null, string } recordGroupSequencingCenter = null;
    union { null, string } recordGroupDescription = null;
    union { null, long } recordGroupRunDateEpoch = null;
    union { null, string } recordGroupFlowOrder = null;
    union { null, string } recordGroupKeySequence = null;
    union { null, string } recordGroupLibrary = null;
    union { null, int } recordGroupPredictedMedianInsertSize = null;
    union { null, string } recordGroupPlatform = null;
    union { null, string } recordGroupPlatformUnit = null;
    union { null, string } recordGroupSample = null;
}

record ADAMNestedPileup {
     // nested pileup data type - contains reference to list of overlapping reads
     // note: cannot be used with databases (e.g. hive/shark)
     ADAMPileup pileup;
     array<ADAMRecord> readEvidence;
}

enum VariantType {
    SNP,
    MNP,
    Insertion,
    Deletion,
    Complex,
    SV
}

record ADAMVariant {
  union { null, string } domainIds;                      // the domain of the samples (e.g. 1000G or 'Hapmap,1000G' etc)
  union { null, int } referenceId = null;
  union { null, string } referenceName = null;
  union { null, long } startPosition = null;
  union { null, string } siteId = null;
  union { null, double } siteQuality = null;
  union { null, string } siteFilter = null;
  union { null, string } ancestralAllele = null;
  union { null, int } alleleCount = null;
  union { null, string } alleleFrequency = null;
  union { null, int } alleleNumber = null;
  union { null, double } rmsBaseQuality = null;
  union { null, string } allelicAlignments = null;
  union { null, boolean } inDbSNP = null;
  union { null, boolean } inHM2 = null;
  union { null, boolean } inHM3 = null;
  union { null, boolean } in1000G = null;
  union { null, double } siteRmsMappingQuality = null;
  union { null, int } siteMapQZeroCounts = null;
  union { null, int } numberOfSamplesWithData = null;
  union { null, double } strandBias = null;
  union { null, boolean } isSomatic = null;
  union { null, boolean } validated = null;
  union { null, string } referenceAllele = null;
  union { null, string } alternateAlleles = null;
  union { null, VariantType } type;
  union { null, string } variantId;

  /* ** site level information -- convenience fields ** */
  union { null, string } callsetIds = null;
  union { null, int } callsetsPresent = null;
  union { null, int } callsetsFiltered = null;
  union { null, string } geneIds = null;
  union { null, string } transcriptIds = null;

}

record ADAMGenotype {

  union { null, string } genotype = null;
  union { null, long } position = null;
  union { null, string } sampleId = null;
  union { null, string } referenceAllele = null;
  union { null, string } siteAlleles = null;
  union { null, string } allele1 = null;
  union { null, string } allele2 = null;
  union { null, double } expectedAllele1Dosage = null;
  union { null, double } expectedAllele2Dosage = null;
  union { null, int } genotypeQuality = null;
  union { null, string } phredLikelihoods = null;
  union { null, string } phredPosteriorLikelihoods = null;
  union { null, string } ploidyStateGenotypeLikelihoods = null;
  union { boolean, null } isPhased = false;
  union { null, boolean } isPhaseSwitch = false;
  union { null, string } phaseSetId = null;
  union { null, double } phaseLikelihood = null;
  union { null, int } haplotype1Quality = null;
  union { null, int } haplotype2Quality = null;
  union { null, double } rmsMappingQuality = null;
  union { null, int } depth = null;
  union { null, string } format = null;

  /* ** sample level information -- convenience fields ** */
  union { null, string } sampleEthnicity = null;
  union { null, string } sampleCohort = null;
  
  union { null, string } recordGroupSequencingCenter = null;
  union { null, string } recordGroupDescription = null;
  union { null, long } recordGroupRunDateEpoch = null;
  union { null, string } recordGroupFlowOrder = null;
  union { null, string } recordGroupKeySequence = null;
  union { null, string } recordGroupLibrary = null;
  union { null, int } recordGroupPredictedMedianInsertSize = null;
  union { null, string } recordGroupPlatform = null;
  union { null, string } recordGroupPlatformUnit = null;
  union { null, string } recordGroupSample = null;

}

// A simplified, flattened version of Genotype / Variants
//
// I'm trying to remove aggregated values (allele counts, total sets of
// alleles, etc) because I'm assuming most of those will have to
// be re-computed on the fly anyway.
//
record ADAMCall {

    // These four fields contain the contents of a SequenceRecord,
    // in parallel to the flattened representation in ADAMRecord.
    //
    union { null, string } referenceName = null;
    union { null, int }    referenceId = null;
    union { null, long }   referenceLength = null;
    union { null, string } referenceUrl = null;

    // The start position along the referenceName sequence
    //
    union { null, long }   start = null;

    union { null, string } referenceAllele = null;
    union { null, string } siteId = null;
    union { null, string } siteFilter = null;
    union { null, double } siteQuality = null;

    // Assuming diploid organisms. I've also experimented with
    // flattening these alleles out into an allele_value and and
    // allele_index
    //
    union { null, string } sampleId = null;
    union { null, string } allele1 = null;
    union { null, string } allele2 = null;
    union { boolean, null } isPhased = false;

    // GT:AD:DP:GQ:PL

    union { null, string }  alleleDepths = null;
    union { null, int }     depth = null;
    union { null, double }     genotypeQuality = null;
    union { null, string }  likelihoods = null;
}

}
